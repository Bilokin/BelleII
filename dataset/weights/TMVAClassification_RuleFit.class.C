// Class: ReadRuleFit
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : RuleFit::RuleFit
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.08/06       [395270]
Creator        : sbilokin
Date           : Mon Feb 12 12:52:37 2018
Host           : Linux ubuntu1604 4.4.0-66-generic #87-Ubuntu SMP Fri Mar 3 15:29:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/sbilokin/BelleII/test
Training events: 2500
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "True" [Print method-specific help message]
GDTau: "-1.000000e+00" [Gradient-directed (GD) path: default fit cut-off]
GDTauPrec: "1.000000e-02" [GD path: precision of tau]
GDStep: "1.000000e-02" [GD path: step size]
GDNSteps: "10000" [GD path: number of steps]
GDErrScale: "1.020000e+00" [Stop scan when error > scale*errmin]
fEventsMin: "1.000000e-02" [Minimum fraction of events in a splittable node]
fEventsMax: "5.000000e-01" [Maximum fraction of events in a splittable node]
nTrees: "20" [Number of trees in forest.]
RuleMinDist: "1.000000e-03" [Minimum distance between rules]
MinImp: "1.000000e-03" [Minimum rule importance accepted]
Model: "modrulelinear" [Model to be used]
RuleFitModule: "rftmva" [Which RuleFit module to use]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
LinQuantile: "2.500000e-02" [Quantile of linear terms (removes outliers)]
GDPathEveFrac: "5.000000e-01" [Fraction of events used for the path search]
GDValidEveFrac: "5.000000e-01" [Fraction of events used for the validation]
ForestType: "adaboost" [Method to use for forest generation (AdaBoost or RandomForest)]
RFWorkDir: "./rulefit" [Friedman's RuleFit module (RFF): working dir]
RFNrules: "2000" [RFF: Mximum number of rules]
RFNendnodes: "4" [RFF: Average number of end nodes]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
B0_CosTBTO                    B0_CosTBTO                    B0_CosTBTO                    B0_CosTBTO                                                      'F'    [0.000398379168473,0.99998241663]
B0_cc2                        B0_cc2                        B0_cc2                        B0_cc2                                                          'F'    [0,8.38051795959]
B0_hso12                      B0_hso12                      B0_hso12                      B0_hso12                                                        'F'    [-0.26410189271,0.799365401268]
B0_R2                         B0_R2                         B0_R2                         B0_R2                                                           'F'    [0.0543055608869,0.88086438179]
B0_hso10                      B0_hso10                      B0_hso10                      B0_hso10                                                        'F'    [0,0.99540835619]
B0_hso14                      B0_hso14                      B0_hso14                      B0_hso14                                                        'F'    [-0.181763574481,0.688618659973]
B0_cc9                        B0_cc9                        B0_cc9                        B0_cc9                                                          'F'    [0,5.943754673]
B0_CosTBz                     B0_CosTBz                     B0_CosTBz                     B0_CosTBz                                                       'F'    [0.000984498881735,0.951700866222]
B0_ThrustO                    B0_ThrustO                    B0_ThrustO                    B0_ThrustO                                                      'F'    [0.5593085289,1]
B0_ThrustB                    B0_ThrustB                    B0_ThrustB                    B0_ThrustB                                                      'F'    [0.837455034256,0.996106863022]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadRuleFit : public IClassifierReader {

 public:

   // constructor
   ReadRuleFit( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadRuleFit" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "B0_CosTBTO", "B0_cc2", "B0_hso12", "B0_R2", "B0_hso10", "B0_hso14", "B0_cc9", "B0_CosTBz", "B0_ThrustO", "B0_ThrustB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadRuleFit() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   // not implemented for class: "ReadRuleFit"
};
void   ReadRuleFit::Initialize(){}
void   ReadRuleFit::Clear(){}
double ReadRuleFit::GetMvaValue__( const std::vector<double>& inputValues ) const {
   double rval=-0.2635520998;
   //
   // here follows all rules ordered in importance (most important first)
   // at the end of each line, the relative importance of the rule is given
   //
   if ((0.761986196<inputValues[0])) rval+=-0.1278484306;   // importance = 0.705
   if ((inputValues[0]<0.7619132996)&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)) rval+=0.1208773675;   // importance = 0.660
   if ((inputValues[4]<0.5214043856)&&(inputValues[7]<0.7253398299)) rval+=0.1262578382;   // importance = 0.628
   if ((inputValues[3]<0.408545047)&&(inputValues[5]<0.0002836287022)&&(inputValues[9]<0.9562088251)) rval+=0.1228379063;   // importance = 0.581
   if ((inputValues[2]<0.1275431216)&&(inputValues[4]<0.5214043856)&&(inputValues[7]<0.7253398299)&&(0.9330928326<inputValues[9])) rval+=0.1072963681;   // importance = 0.546
   if ((inputValues[1]<2.3038311)&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=0.0915834995;   // importance = 0.519
   if ((inputValues[3]<0.408545047)&&(inputValues[9]<0.9562088251)) rval+=0.08894348908;   // importance = 0.509
   if ((inputValues[0]<0.9523831606)) rval+=0.09563054373;   // importance = 0.495
   if ((inputValues[3]<0.408545047)&&(0.924957633<inputValues[9])) rval+=0.09545952711;   // importance = 0.495
   if ((0.2904652357<inputValues[3])) rval+=-0.09020934835;   // importance = 0.477
   if ((inputValues[1]<2.3038311)&&(inputValues[4]<0.2447846234)&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=0.09762315015;   // importance = 0.459
   if ((inputValues[2]<0.1275431216)&&(inputValues[4]<0.5214043856)&&(inputValues[7]<0.7253398299)) rval+=0.0791237931;   // importance = 0.452
   if ((inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)) rval+=0.08082852806;   // importance = 0.445
   if ((inputValues[3]<0.4872649312)) rval+=0.08640502159;   // importance = 0.437
   if ((-0.02766372636<inputValues[2])&&(inputValues[4]<0.5214043856)&&(0.008315746672<inputValues[5])&&(inputValues[7]<0.7253398299)) rval+=-0.0771052637;   // importance = 0.425
   if ((1.044040322<inputValues[1])&&(inputValues[1]<1.995361447)&&(0.9043906927<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.08806168059;   // importance = 0.415
   if ((0.6065993309<inputValues[1])&&(0.08005839586<inputValues[2])) rval+=-0.07175465435;   // importance = 0.404
   if ((0.761986196<inputValues[0])&&(0.06691706181<inputValues[5])) rval+=-0.07227169049;   // importance = 0.380
   if ((inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=0.06591565794;   // importance = 0.377
   if ((inputValues[1]<2.060069323)&&(inputValues[7]<0.4989787936)) rval+=0.06460203845;   // importance = 0.368
   if ((0.03974590451<inputValues[2])) rval+=-0.06222366049;   // importance = 0.347
   if ((0.5442509651<inputValues[7])&&(0.929202795<inputValues[9])) rval+=-0.07907977244;   // importance = 0.342
   if ((inputValues[2]<0.03974590451)) rval+=0.05898911811;   // importance = 0.329
   if ((0.5442509651<inputValues[7])&&(inputValues[9]<0.929202795)) rval+=0.07488781814;   // importance = 0.305
   if ((-0.015976483<inputValues[5])) rval+=-0.06471697252;   // importance = 0.300
   if ((0.3691851199<inputValues[3])&&(-0.015976483<inputValues[5])&&(0.941021204<inputValues[9])) rval+=-0.06125210207;   // importance = 0.295
   if ((inputValues[0]<0.7619132996)&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)&&(0.757796824<inputValues[8])) rval+=0.07446710713;   // importance = 0.294
   if ((1.140024662<inputValues[1])) rval+=-0.05037394254;   // importance = 0.284
   if ((0.2810723186<inputValues[3])&&(inputValues[3]<0.4872649312)&&(0.3838143051<inputValues[6])) rval+=-0.064594801;   // importance = 0.277
   if ((1.044040322<inputValues[1])&&(inputValues[1]<1.995361447)&&(inputValues[4]<0.314591229)&&(0.9043906927<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.07566304416;   // importance = 0.276
   if ((0.761986196<inputValues[0])&&(inputValues[5]<0.06691706181)) rval+=-0.051013684;   // importance = 0.275
   if ((0.3691851199<inputValues[3])&&(-0.015976483<inputValues[5])&&(inputValues[9]<0.941021204)) rval+=-0.05749629266;   // importance = 0.275
   if ((-0.02766372636<inputValues[2])&&(inputValues[4]<0.5214043856)&&(inputValues[5]<0.008315746672)&&(inputValues[7]<0.7253398299)) rval+=0.05316272241;   // importance = 0.273
   if ((1.197216868<inputValues[1])&&(0.1896015853<inputValues[4])) rval+=-0.04782835165;   // importance = 0.272
   if ((inputValues[2]<0.03944903612)&&(inputValues[3]<0.3691851199)&&(-0.015976483<inputValues[5])) rval+=0.05855386105;   // importance = 0.272
   if ((0.408545047<inputValues[3])&&(0.06691706181<inputValues[5])) rval+=-0.05512755207;   // importance = 0.270
   if ((0.2904652357<inputValues[3])&&(0.7253580689<inputValues[7])) rval+=-0.0767259289;   // importance = 0.262
   if ((0.03974590451<inputValues[2])&&(0.361580193<inputValues[4])) rval+=-0.04876272304;   // importance = 0.260
   if ((inputValues[5]<0.06691706181)) rval+=0.04738606226;   // importance = 0.256
   if ((inputValues[0]<0.9523831606)&&(1.669801116<inputValues[1])) rval+=0.05215866068;   // importance = 0.256
   if ((inputValues[0]<0.9523831606)&&(inputValues[1]<1.669801116)) rval+=0.04360597707;   // importance = 0.249
   if ((0.9082407355<inputValues[0])&&(1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)&&(0.7464317083<inputValues[8])) rval+=-0.056272116;   // importance = 0.243
   if ((inputValues[7]<0.4989787936)) rval+=0.04337990041;   // importance = 0.241
   if ((0.9495798349<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.05188562563;   // importance = 0.234
   if ((0.9047839642<inputValues[0])&&(inputValues[1]<1.596289158)) rval+=-0.05307243908;   // importance = 0.233
   if ((0.2901275754<inputValues[0])&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)) rval+=-0.03969332399;   // importance = 0.227
   if ((inputValues[1]<1.995361447)&&(0.9495798349<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.06015588032;   // importance = 0.224
   if ((inputValues[0]<0.7619132996)&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)&&(inputValues[8]<0.757796824)) rval+=0.04684594189;   // importance = 0.219
   if ((inputValues[3]<0.408545047)&&(inputValues[8]<0.717179656)&&(0.924957633<inputValues[9])) rval+=0.05459088867;   // importance = 0.214
   if ((0.09808915108<inputValues[1])&&(0.3088218868<inputValues[4])&&(inputValues[7]<0.4989787936)) rval+=-0.04178491151;   // importance = 0.214
   if ((0.4832158089<inputValues[3])&&(inputValues[5]<0.108363837)) rval+=-0.0540373583;   // importance = 0.211
   if ((inputValues[4]<0.3318027854)&&(0.4989787936<inputValues[7])) rval+=-0.04500404695;   // importance = 0.206
   if ((0.09808915108<inputValues[1])&&(inputValues[4]<0.3088218868)&&(inputValues[7]<0.4989787936)) rval+=0.03806747934;   // importance = 0.195
   if ((inputValues[3]<0.2904652357)&&(0.7691472173<inputValues[8])) rval+=0.05997376421;   // importance = 0.188
   if ((0.9708227515<inputValues[1])&&(inputValues[1]<2.3038311)&&(0.2447846234<inputValues[4])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=0.05084948136;   // importance = 0.177
   if ((inputValues[3]<0.408545047)&&(0.0002836287022<inputValues[5])&&(inputValues[9]<0.9562088251)) rval+=-0.03480850677;   // importance = 0.175
   if ((inputValues[1]<2.3038311)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.03625162306;   // importance = 0.174
   if ((0.7710495591<inputValues[0])&&(inputValues[0]<0.9523831606)) rval+=-0.03167805462;   // importance = 0.172
   if ((inputValues[3]<0.408545047)&&(0.717179656<inputValues[8])&&(0.924957633<inputValues[9])) rval+=0.04072547777;   // importance = 0.168
   if ((inputValues[0]<0.9082407355)&&(1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)&&(0.7464317083<inputValues[8])) rval+=0.05661058694;   // importance = 0.150
   if ((0.9281132221<inputValues[9])) rval+=0.02630267491;   // importance = 0.149
   if ((0.408545047<inputValues[3])&&(inputValues[4]<0.4760001302)&&(0.06691706181<inputValues[5])) rval+=-0.03714288155;   // importance = 0.147
   if ((0.2901275754<inputValues[0])&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)&&(inputValues[9]<0.924957633)) rval+=-0.02979870838;   // importance = 0.146
   if ((inputValues[2]<0.1275431216)&&(inputValues[4]<0.5214043856)&&(inputValues[7]<0.7253398299)&&(inputValues[9]<0.9330928326)) rval+=-0.02704432118;   // importance = 0.135
   if ((inputValues[0]<0.8571847081)&&(inputValues[8]<0.7062056661)) rval+=-0.03213965494;   // importance = 0.135
   if ((1.596289158<inputValues[1])&&(inputValues[2]<0.08005839586)) rval+=-0.03089702883;   // importance = 0.132
   if ((inputValues[4]<0.3318027854)&&(0.4989787936<inputValues[7])&&(inputValues[7]<0.6472876668)) rval+=0.0395591075;   // importance = 0.130
   if ((inputValues[3]<0.2904652357)&&(inputValues[8]<0.7691472173)) rval+=0.02708195162;   // importance = 0.130
   if ((0.8571847081<inputValues[0])&&(inputValues[8]<0.7062056661)) rval+=0.04892963873;   // importance = 0.128
   if ((inputValues[1]<1.596289158)&&(0.939416647<inputValues[9])) rval+=-0.02661903167;   // importance = 0.128
   if ((0.2162582874<inputValues[3])&&(inputValues[3]<0.4872649312)) rval+=-0.02213742304;   // importance = 0.125
   if ((inputValues[4]<0.401186496)&&(inputValues[9]<0.9356302023)) rval+=0.01998821875;   // importance = 0.109
   if ((inputValues[1]<1.197216868)&&(0.1896015853<inputValues[4])) rval+=-0.02055867355;   // importance = 0.109
   if ((-0.02766372636<inputValues[2])&&(inputValues[4]<0.5214043856)&&(inputValues[7]<0.7253398299)) rval+=-0.01905674189;   // importance = 0.105
   if ((0.2810723186<inputValues[3])&&(inputValues[3]<0.4872649312)&&(inputValues[6]<0.3838143051)&&(inputValues[8]<0.7794490457)) rval+=0.02340649904;   // importance = 0.093
   if ((1.001880646<inputValues[1])&&(0.3028014004<inputValues[4])&&(0.9363859892<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.02295362405;   // importance = 0.090
   if ((0.7062056661<inputValues[8])) rval+=-0.01897692543;   // importance = 0.089
   if ((0.007661593147<inputValues[5])&&(inputValues[5]<0.06691706181)&&(0.5895231962<inputValues[7])) rval+=-0.02832246386;   // importance = 0.088
   if ((inputValues[1]<1.716724396)&&(0.2904652357<inputValues[3])&&(0.0104840314<inputValues[5])&&(inputValues[7]<0.7253580689)) rval+=-0.01952315115;   // importance = 0.087
   if ((inputValues[3]<0.408545047)&&(inputValues[4]<0.2752673328)&&(0.717179656<inputValues[8])&&(0.924957633<inputValues[9])) rval+=0.02726102266;   // importance = 0.087
   if ((inputValues[8]<0.7062056661)) rval+=0.01824861437;   // importance = 0.086
   if ((inputValues[9]<0.9658874869)) rval+=0.0232613446;   // importance = 0.084
   if ((inputValues[1]<1.596289158)) rval+=-0.01421175607;   // importance = 0.081
   if ((-0.02766372636<inputValues[2])&&(0.1985697299<inputValues[4])&&(inputValues[4]<0.5214043856)&&(inputValues[5]<0.008315746672)&&(inputValues[7]<0.7253398299)) rval+=-0.01864548956;   // importance = 0.076
   if ((inputValues[5]<0.06691706181)&&(0.5895231962<inputValues[7])) rval+=-0.01794278309;   // importance = 0.076
   if ((2.3038311<inputValues[1])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.02428497521;   // importance = 0.073
   if ((inputValues[3]<0.2904652357)&&(0.334587872<inputValues[7])&&(0.7691472173<inputValues[8])) rval+=0.03191622979;   // importance = 0.071
   if ((0.2810723186<inputValues[3])&&(inputValues[3]<0.4872649312)&&(inputValues[6]<0.3838143051)&&(0.7794490457<inputValues[8])) rval+=-0.01802940319;   // importance = 0.071
   if ((0.2370019853<inputValues[4])&&(inputValues[9]<0.9130035043)) rval+=-0.01534309316;   // importance = 0.065
   if ((0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)) rval+=-0.01129797027;   // importance = 0.064
   if ((inputValues[3]<0.2904652357)&&(inputValues[7]<0.5438675284)&&(0.7691472173<inputValues[8])) rval+=0.02175026565;   // importance = 0.060
   if ((inputValues[1]<1.596289158)&&(inputValues[9]<0.939416647)) rval+=0.01102100847;   // importance = 0.059
   if ((inputValues[1]<2.3038311)&&(inputValues[2]<0.09696373343)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.01294701085;   // importance = 0.056
   if ((0.2901275754<inputValues[0])&&(inputValues[3]<0.4832158089)&&(inputValues[5]<0.108363837)&&(0.924957633<inputValues[9])) rval+=-0.01055121833;   // importance = 0.055
   if ((inputValues[1]<1.716724396)&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)) rval+=-0.009908229525;   // importance = 0.052
   if ((inputValues[1]<2.3038311)&&(0.09696373343<inputValues[2])&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.02051955788;   // importance = 0.051
   if ((0.2370019853<inputValues[4])) rval+=-0.00890485173;   // importance = 0.049
   if ((0.03974590451<inputValues[2])&&(inputValues[4]<0.361580193)) rval+=-0.009088494267;   // importance = 0.047
   if ((0.3318027854<inputValues[4])&&(0.4989787936<inputValues[7])) rval+=0.01020118508;   // importance = 0.044
   if ((inputValues[4]<0.2370019853)) rval+=0.00791250816;   // importance = 0.043
   if ((0.408545047<inputValues[3])&&(0.4760001302<inputValues[4])&&(0.06691706181<inputValues[5])) rval+=-0.01200507381;   // importance = 0.042
   if ((1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)&&(0.7464317083<inputValues[8])&&(inputValues[8]<0.8309548497)) rval+=-0.01125934735;   // importance = 0.041
   if ((inputValues[1]<2.060069323)&&(0.3065511584<inputValues[7])&&(inputValues[7]<0.4989787936)) rval+=-0.009201182558;   // importance = 0.040
   if ((1.044040322<inputValues[1])&&(inputValues[1]<1.995361447)&&(0.314591229<inputValues[4])&&(0.9043906927<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=0.01148718736;   // importance = 0.040
   if ((inputValues[1]<1.716724396)&&(0.2904652357<inputValues[3])&&(inputValues[5]<0.0104840314)&&(inputValues[7]<0.7253580689)) rval+=0.010115435;   // importance = 0.038
   if ((0.2370019853<inputValues[4])&&(0.01463045646<inputValues[5])) rval+=-0.006632723529;   // importance = 0.038
   if ((inputValues[3]<0.408545047)&&(0.2752673328<inputValues[4])&&(0.717179656<inputValues[8])&&(0.924957633<inputValues[9])) rval+=0.0127843263;   // importance = 0.037
   if ((0.7710495591<inputValues[0])&&(inputValues[0]<0.9523831606)&&(inputValues[3]<0.253267616)) rval+=-0.02375297744;   // importance = 0.035
   if ((1.335840821<inputValues[1])&&(inputValues[4]<0.2370019853)&&(0.9356302023<inputValues[9])) rval+=0.01031120059;   // importance = 0.034
   if ((0.09808915108<inputValues[1])&&(0.3081754446<inputValues[7])&&(inputValues[7]<0.4989787936)) rval+=0.007197615239;   // importance = 0.034
   if ((0.7710495591<inputValues[0])&&(inputValues[0]<0.9523831606)&&(0.253267616<inputValues[3])) rval+=-0.006206687248;   // importance = 0.033
   if ((1.001880646<inputValues[1])&&(inputValues[4]<0.3028014004)&&(0.9363859892<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=-0.008870416955;   // importance = 0.032
   if ((1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)) rval+=0.006205110166;   // importance = 0.032
   if ((inputValues[3]<0.408545047)&&(0.06691706181<inputValues[5])) rval+=0.009267724561;   // importance = 0.031
   if ((0.5442509651<inputValues[7])) rval+=-0.005705642177;   // importance = 0.030
   if ((0.7614011765<inputValues[0])&&(inputValues[1]<2.3038311)&&(inputValues[2]<0.09696373343)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)&&(inputValues[9]<0.9300225973)) rval+=-0.01603805493;   // importance = 0.030
   if ((inputValues[1]<2.3038311)&&(0.2447846234<inputValues[4])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.006036656301;   // importance = 0.028
   if ((inputValues[4]<0.2370019853)&&(0.9356302023<inputValues[9])) rval+=0.006228830193;   // importance = 0.027
   if ((0.408545047<inputValues[3])&&(inputValues[3]<0.4528395236)&&(inputValues[5]<0.06691706181)) rval+=-0.009031731582;   // importance = 0.026
   if ((0.3318027854<inputValues[4])&&(0.01220784802<inputValues[5])&&(0.4989787936<inputValues[7])) rval+=0.00640152617;   // importance = 0.025
   if ((0.03944903612<inputValues[2])&&(inputValues[3]<0.3691851199)&&(-0.015976483<inputValues[5])) rval+=0.006348370259;   // importance = 0.025
   if ((0.09808915108<inputValues[1])&&(inputValues[7]<0.4989787936)) rval+=-0.004054332324;   // importance = 0.023
   if ((0.7614011765<inputValues[0])&&(inputValues[1]<2.3038311)&&(inputValues[2]<0.09696373343)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.008257037428;   // importance = 0.023
   if ((inputValues[1]<1.335840821)&&(inputValues[4]<0.2370019853)&&(0.9356302023<inputValues[9])) rval+=-0.006899780513;   // importance = 0.021
   if ((1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)&&(inputValues[8]<0.7464317083)) rval+=0.007712208136;   // importance = 0.021
   if ((0.2810723186<inputValues[3])&&(inputValues[3]<0.4872649312)&&(inputValues[6]<0.3838143051)) rval+=0.00351512191;   // importance = 0.018
   if ((0.7614011765<inputValues[0])&&(inputValues[1]<2.3038311)&&(inputValues[2]<0.09696373343)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)&&(0.9300225973<inputValues[9])) rval+=0.007656813408;   // importance = 0.016
   if ((inputValues[0]<0.7614011765)&&(inputValues[1]<2.3038311)&&(inputValues[2]<0.09696373343)&&(-0.003253625939<inputValues[5])&&(inputValues[5]<0.06691706181)&&(inputValues[7]<0.5895231962)) rval+=-0.003232874212;   // importance = 0.012
   if ((1.995361447<inputValues[1])&&(0.9495798349<inputValues[9])&&(inputValues[9]<0.9658874869)) rval+=-0.003682547099;   // importance = 0.011
   if ((0.2370019853<inputValues[4])&&(inputValues[5]<0.01463045646)) rval+=-0.001985360894;   // importance = 0.009
   if ((1.716724396<inputValues[1])&&(0.2904652357<inputValues[3])&&(inputValues[7]<0.7253580689)&&(0.7464317083<inputValues[8])) rval+=0.001504476345;   // importance = 0.007
   if ((0.3318027854<inputValues[4])&&(inputValues[5]<0.01220784802)&&(0.4989787936<inputValues[7])) rval+=0.002291348439;   // importance = 0.005
   //
   // here follows all linear terms
   // at the end of each line, the relative importance of the term is given
   //
   rval+=-0.1348330377*std::min( double(0.9968801141), std::max( double(inputValues[0]), double(0.06016540155)));   // importance = 0.470
   rval+=-0.06501848883*std::min( double(4.850762367), std::max( double(inputValues[1]), double(0)));   // importance = 1.000
   rval+=-0.07156262354*std::min( double(0.470174849), std::max( double(inputValues[2]), double(-0.0997345373)));   // importance = 0.125
   rval+=-0.115126039*std::min( double(0.6846792698), std::max( double(inputValues[3]), double(0.1297759265)));   // importance = 0.212
   rval+=-0.09243994729*std::min( double(0.7023659945), std::max( double(inputValues[4]), double(0.03403901309)));   // importance = 0.196
   rval+=-0.0522178984*std::min( double(0.3418086767), std::max( double(inputValues[5]), double(-0.08037114143)));   // importance = 0.064
   rval+=0.002670493808*std::min( double(2.030666828), std::max( double(inputValues[6]), double(0)));   // importance = 0.017
   rval+=-0.03338342831*std::min( double(0.8668709397), std::max( double(inputValues[7]), double(0.02283620276)));   // importance = 0.102
   rval+=-0.01062183653*std::min( double(0.9381933808), std::max( double(inputValues[8]), double(0.6250126362)));   // importance = 0.011
   rval+=0.03380148014*std::min( double(0.9790548682), std::max( double(inputValues[9]), double(0.8701524138)));   // importance = 0.012
   return rval;
}
   inline double ReadRuleFit::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
