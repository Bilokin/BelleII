// Class: ReadCutsD
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : Cuts::CutsD
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.08/06       [395270]
Creator        : sbilokin
Date           : Mon Feb 12 12:50:27 2018
Host           : Linux ubuntu1604 4.4.0-66-generic #87-Ubuntu SMP Fri Mar 3 15:29:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/sbilokin/BelleII/test
Training events: 2500
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
VarTransform: "Decorrelate" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
FitMethod: "MC" [Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated)]
EffMethod: "EffSel" [Selection Method]
# Default:
VerbosityLevel: "Default" [Verbosity level]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
CutRangeMin[0]: "-1.000000e+00" [Minimum of allowed cut range (set per variable)]
    CutRangeMin[1]: "-1.000000e+00"
    CutRangeMin[2]: "-1.000000e+00"
    CutRangeMin[3]: "-1.000000e+00"
    CutRangeMin[4]: "-1.000000e+00"
    CutRangeMin[5]: "-1.000000e+00"
    CutRangeMin[6]: "-1.000000e+00"
    CutRangeMin[7]: "-1.000000e+00"
    CutRangeMin[8]: "-1.000000e+00"
    CutRangeMin[9]: "-1.000000e+00"
CutRangeMax[0]: "-1.000000e+00" [Maximum of allowed cut range (set per variable)]
    CutRangeMax[1]: "-1.000000e+00"
    CutRangeMax[2]: "-1.000000e+00"
    CutRangeMax[3]: "-1.000000e+00"
    CutRangeMax[4]: "-1.000000e+00"
    CutRangeMax[5]: "-1.000000e+00"
    CutRangeMax[6]: "-1.000000e+00"
    CutRangeMax[7]: "-1.000000e+00"
    CutRangeMax[8]: "-1.000000e+00"
    CutRangeMax[9]: "-1.000000e+00"
VarProp[0]: "FSmart" [Categorisation of cuts]
    VarProp[1]: "FSmart"
    VarProp[2]: "FSmart"
    VarProp[3]: "FSmart"
    VarProp[4]: "FSmart"
    VarProp[5]: "FSmart"
    VarProp[6]: "FSmart"
    VarProp[7]: "FSmart"
    VarProp[8]: "FSmart"
    VarProp[9]: "FSmart"
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
B0_CosTBTO                    B0_CosTBTO                    B0_CosTBTO                    B0_CosTBTO                                                      'F'    [0.000398379168473,0.99998241663]
B0_cc2                        B0_cc2                        B0_cc2                        B0_cc2                                                          'F'    [0,8.38051795959]
B0_hso12                      B0_hso12                      B0_hso12                      B0_hso12                                                        'F'    [-0.26410189271,0.799365401268]
B0_R2                         B0_R2                         B0_R2                         B0_R2                                                           'F'    [0.0543055608869,0.88086438179]
B0_hso10                      B0_hso10                      B0_hso10                      B0_hso10                                                        'F'    [0,0.99540835619]
B0_hso14                      B0_hso14                      B0_hso14                      B0_hso14                                                        'F'    [-0.181763574481,0.688618659973]
B0_cc9                        B0_cc9                        B0_cc9                        B0_cc9                                                          'F'    [0,5.943754673]
B0_CosTBz                     B0_CosTBz                     B0_CosTBz                     B0_CosTBz                                                       'F'    [0.000984498881735,0.951700866222]
B0_ThrustO                    B0_ThrustO                    B0_ThrustO                    B0_ThrustO                                                      'F'    [0.5593085289,1]
B0_ThrustB                    B0_ThrustB                    B0_ThrustB                    B0_ThrustB                                                      'F'    [0.837455034256,0.996106863022]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadCutsD : public IClassifierReader {

 public:

   // constructor
   ReadCutsD( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadCutsD" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "B0_CosTBTO", "B0_cc2", "B0_hso12", "B0_R2", "B0_hso10", "B0_hso14", "B0_cc9", "B0_CosTBz", "B0_ThrustO", "B0_ThrustB" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 1.01973354816437;
      fVmax[0] = 7.30894231796265;
      fVmin[1] = -0.409707456827164;
      fVmax[1] = 6.33974981307983;
      fVmin[2] = -5.73273372650146;
      fVmax[2] = 2.60731410980225;
      fVmin[3] = -10.7199811935425;
      fVmax[3] = -3.40346312522888;
      fVmin[4] = -0.677354037761688;
      fVmax[4] = 5.61551809310913;
      fVmin[5] = -4.34278535842896;
      fVmax[5] = 5.1251392364502;
      fVmin[6] = 0.0504411160945892;
      fVmax[6] = 11.7340211868286;
      fVmin[7] = -0.196703761816025;
      fVmax[7] = 3.95016503334045;
      fVmin[8] = 11.2833375930786;
      fVmax[8] = 19.6163806915283;
      fVmin[9] = 35.8900566101074;
      fVmax[9] = 41.9169921875;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

      // initialize transformation
      InitTransform();
   }

   // destructor
   virtual ~ReadCutsD() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // input variable transformation

   double fDecTF_1[3][10][10];
   void InitTransform_1();
   void Transform_1( std::vector<double> & iv, int sigOrBgd ) const;
   void InitTransform();
   void Transform( std::vector<double> & iv, int sigOrBgd ) const;

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   // not implemented for class: "ReadCutsD"
};
   inline double ReadCutsD::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            Transform( iV, -1 );
            retval = GetMvaValue__( iV );
         }
         else {
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(*varIt);
            }
            Transform( iV, -1 );
            retval = GetMvaValue__( iV );
         }
      }

      return retval;
   }

//_______________________________________________________________________
inline void ReadCutsD::InitTransform_1()
{
   // Decorrelation transformation, initialisation
   fDecTF_1[0][0][0] = 4.49713350849;
   fDecTF_1[0][0][1] = -0.0900306820021;
   fDecTF_1[0][0][2] = -1.04898532953;
   fDecTF_1[0][0][3] = -2.45068698325;
   fDecTF_1[0][0][4] = -0.300754407129;
   fDecTF_1[0][0][5] = -0.115322627333;
   fDecTF_1[0][0][6] = 0.443670109524;
   fDecTF_1[0][0][7] = -0.0560300056374;
   fDecTF_1[0][0][8] = 0.629919908613;
   fDecTF_1[0][0][9] = 1.17464894062;
   fDecTF_1[0][1][0] = -0.0900306820021;
   fDecTF_1[0][1][1] = 1.16577861897;
   fDecTF_1[0][1][2] = -0.0762395066722;
   fDecTF_1[0][1][3] = -0.169778237066;
   fDecTF_1[0][1][4] = 0.00431023024601;
   fDecTF_1[0][1][5] = -0.0496509315026;
   fDecTF_1[0][1][6] = 0.0196517913887;
   fDecTF_1[0][1][7] = -0.0308922535898;
   fDecTF_1[0][1][8] = 0.0575405525391;
   fDecTF_1[0][1][9] = -0.158739799484;
   fDecTF_1[0][2][0] = -1.04898532953;
   fDecTF_1[0][2][1] = -0.0762395066722;
   fDecTF_1[0][2][2] = 15.595255502;
   fDecTF_1[0][2][3] = -1.3323773957;
   fDecTF_1[0][2][4] = -0.504045463691;
   fDecTF_1[0][2][5] = 0.100446239507;
   fDecTF_1[0][2][6] = 0.147639499509;
   fDecTF_1[0][2][7] = -0.28271293437;
   fDecTF_1[0][2][8] = 0.371182541057;
   fDecTF_1[0][2][9] = 0.886049816935;
   fDecTF_1[0][3][0] = -2.45068698325;
   fDecTF_1[0][3][1] = -0.169778237066;
   fDecTF_1[0][3][2] = -1.3323773957;
   fDecTF_1[0][3][3] = 15.7041619108;
   fDecTF_1[0][3][4] = 0.753886760709;
   fDecTF_1[0][3][5] = -0.492225948316;
   fDecTF_1[0][3][6] = 0.53303256551;
   fDecTF_1[0][3][7] = -0.0163287347666;
   fDecTF_1[0][3][8] = -3.5485827083;
   fDecTF_1[0][3][9] = -5.80143615797;
   fDecTF_1[0][4][0] = -0.300754407129;
   fDecTF_1[0][4][1] = 0.00431023024601;
   fDecTF_1[0][4][2] = -0.504045463691;
   fDecTF_1[0][4][3] = 0.753886760709;
   fDecTF_1[0][4][4] = 7.06591129106;
   fDecTF_1[0][4][5] = 0.234198246455;
   fDecTF_1[0][4][6] = -0.110971971103;
   fDecTF_1[0][4][7] = -0.0773092694999;
   fDecTF_1[0][4][8] = 0.518278462402;
   fDecTF_1[0][4][9] = -0.533625363251;
   fDecTF_1[0][5][0] = -0.115322627333;
   fDecTF_1[0][5][1] = -0.0496509315026;
   fDecTF_1[0][5][2] = 0.100446239507;
   fDecTF_1[0][5][3] = -0.492225948316;
   fDecTF_1[0][5][4] = 0.234198246455;
   fDecTF_1[0][5][5] = 21.5408510961;
   fDecTF_1[0][5][6] = -0.368247731499;
   fDecTF_1[0][5][7] = -0.0317302448126;
   fDecTF_1[0][5][8] = 0.505861254207;
   fDecTF_1[0][5][9] = 0.472031018309;
   fDecTF_1[0][6][0] = 0.443670109524;
   fDecTF_1[0][6][1] = 0.0196517913887;
   fDecTF_1[0][6][2] = 0.147639499509;
   fDecTF_1[0][6][3] = 0.53303256551;
   fDecTF_1[0][6][4] = -0.110971971103;
   fDecTF_1[0][6][5] = -0.368247731499;
   fDecTF_1[0][6][6] = 1.49277684908;
   fDecTF_1[0][6][7] = -0.0909615748235;
   fDecTF_1[0][6][8] = -0.0389404335936;
   fDecTF_1[0][6][9] = -0.127102223418;
   fDecTF_1[0][7][0] = -0.0560300056374;
   fDecTF_1[0][7][1] = -0.0308922535898;
   fDecTF_1[0][7][2] = -0.28271293437;
   fDecTF_1[0][7][3] = -0.0163287347666;
   fDecTF_1[0][7][4] = -0.0773092694999;
   fDecTF_1[0][7][5] = -0.0317302448126;
   fDecTF_1[0][7][6] = -0.0909615748235;
   fDecTF_1[0][7][7] = 4.53351733189;
   fDecTF_1[0][7][8] = 0.130169311263;
   fDecTF_1[0][7][9] = 0.156717681708;
   fDecTF_1[0][8][0] = 0.629919908613;
   fDecTF_1[0][8][1] = 0.0575405525391;
   fDecTF_1[0][8][2] = 0.371182541057;
   fDecTF_1[0][8][3] = -3.5485827083;
   fDecTF_1[0][8][4] = 0.518278462402;
   fDecTF_1[0][8][5] = 0.505861254207;
   fDecTF_1[0][8][6] = -0.0389404335936;
   fDecTF_1[0][8][7] = 0.130169311263;
   fDecTF_1[0][8][8] = 13.7410235413;
   fDecTF_1[0][8][9] = 1.69971772369;
   fDecTF_1[0][9][0] = 1.17464894062;
   fDecTF_1[0][9][1] = -0.158739799484;
   fDecTF_1[0][9][2] = 0.886049816935;
   fDecTF_1[0][9][3] = -5.80143615797;
   fDecTF_1[0][9][4] = -0.533625363251;
   fDecTF_1[0][9][5] = 0.472031018309;
   fDecTF_1[0][9][6] = -0.127102223418;
   fDecTF_1[0][9][7] = 0.156717681708;
   fDecTF_1[0][9][8] = 1.69971772369;
   fDecTF_1[0][9][9] = 40.9672819346;
   fDecTF_1[1][0][0] = 8.57059616793;
   fDecTF_1[1][0][1] = -0.113129311438;
   fDecTF_1[1][0][2] = -1.15335733507;
   fDecTF_1[1][0][3] = -2.77282894917;
   fDecTF_1[1][0][4] = -0.0950341184941;
   fDecTF_1[1][0][5] = 0.187278250153;
   fDecTF_1[1][0][6] = 0.835031494996;
   fDecTF_1[1][0][7] = 0.206961542777;
   fDecTF_1[1][0][8] = 1.58381718692;
   fDecTF_1[1][0][9] = 1.89385080974;
   fDecTF_1[1][1][0] = -0.113129311438;
   fDecTF_1[1][1][1] = 0.722383046223;
   fDecTF_1[1][1][2] = -0.0223727595395;
   fDecTF_1[1][1][3] = -0.132808268795;
   fDecTF_1[1][1][4] = -0.0298754229886;
   fDecTF_1[1][1][5] = -0.058583079404;
   fDecTF_1[1][1][6] = 0.00506252796148;
   fDecTF_1[1][1][7] = 0.00565191798731;
   fDecTF_1[1][1][8] = -0.0390616891034;
   fDecTF_1[1][1][9] = 0.0176413334656;
   fDecTF_1[1][2][0] = -1.15335733507;
   fDecTF_1[1][2][1] = -0.0223727595395;
   fDecTF_1[1][2][2] = 15.5159385763;
   fDecTF_1[1][2][3] = -1.83750743479;
   fDecTF_1[1][2][4] = -4.91093212664;
   fDecTF_1[1][2][5] = -6.2162732713;
   fDecTF_1[1][2][6] = 0.417318734021;
   fDecTF_1[1][2][7] = -0.0482496106885;
   fDecTF_1[1][2][8] = -1.39799375872;
   fDecTF_1[1][2][9] = 0.72704256824;
   fDecTF_1[1][3][0] = -2.77282894917;
   fDecTF_1[1][3][1] = -0.132808268795;
   fDecTF_1[1][3][2] = -1.83750743479;
   fDecTF_1[1][3][3] = 16.3729466608;
   fDecTF_1[1][3][4] = 1.41312215516;
   fDecTF_1[1][3][5] = -1.81000615843;
   fDecTF_1[1][3][6] = 0.666988136768;
   fDecTF_1[1][3][7] = -0.134953171207;
   fDecTF_1[1][3][8] = -9.61227439682;
   fDecTF_1[1][3][9] = -9.83253368792;
   fDecTF_1[1][4][0] = -0.0950341184941;
   fDecTF_1[1][4][1] = -0.0298754229886;
   fDecTF_1[1][4][2] = -4.91093212664;
   fDecTF_1[1][4][3] = 1.41312215516;
   fDecTF_1[1][4][4] = 8.14994543587;
   fDecTF_1[1][4][5] = -0.0178912229266;
   fDecTF_1[1][4][6] = -0.201465557961;
   fDecTF_1[1][4][7] = 0.111523232675;
   fDecTF_1[1][4][8] = 0.160043781116;
   fDecTF_1[1][4][9] = -1.02202113775;
   fDecTF_1[1][5][0] = 0.187278250153;
   fDecTF_1[1][5][1] = -0.058583079404;
   fDecTF_1[1][5][2] = -6.2162732713;
   fDecTF_1[1][5][3] = -1.81000615843;
   fDecTF_1[1][5][4] = -0.0178912229266;
   fDecTF_1[1][5][5] = 13.9153527114;
   fDecTF_1[1][5][6] = -0.372862014848;
   fDecTF_1[1][5][7] = -0.00411900492519;
   fDecTF_1[1][5][8] = 0.80341665174;
   fDecTF_1[1][5][9] = 1.04454621784;
   fDecTF_1[1][6][0] = 0.835031494996;
   fDecTF_1[1][6][1] = 0.00506252796148;
   fDecTF_1[1][6][2] = 0.417318734021;
   fDecTF_1[1][6][3] = 0.666988136768;
   fDecTF_1[1][6][4] = -0.201465557961;
   fDecTF_1[1][6][5] = -0.372862014848;
   fDecTF_1[1][6][6] = 2.96766211234;
   fDecTF_1[1][6][7] = 4.99545324694e-05;
   fDecTF_1[1][6][8] = 0.699092686755;
   fDecTF_1[1][6][9] = 0.0684181769473;
   fDecTF_1[1][7][0] = 0.206961542777;
   fDecTF_1[1][7][1] = 0.00565191798731;
   fDecTF_1[1][7][2] = -0.0482496106885;
   fDecTF_1[1][7][3] = -0.134953171207;
   fDecTF_1[1][7][4] = 0.111523232675;
   fDecTF_1[1][7][5] = -0.00411900492519;
   fDecTF_1[1][7][6] = 4.99545324694e-05;
   fDecTF_1[1][7][7] = 3.91536977003;
   fDecTF_1[1][7][8] = 0.0692994735238;
   fDecTF_1[1][7][9] = 0.0575872089294;
   fDecTF_1[1][8][0] = 1.58381718692;
   fDecTF_1[1][8][1] = -0.0390616891034;
   fDecTF_1[1][8][2] = -1.39799375872;
   fDecTF_1[1][8][3] = -9.61227439682;
   fDecTF_1[1][8][4] = 0.160043781116;
   fDecTF_1[1][8][5] = 0.80341665174;
   fDecTF_1[1][8][6] = 0.699092686755;
   fDecTF_1[1][8][7] = 0.0692994735238;
   fDecTF_1[1][8][8] = 23.450336182;
   fDecTF_1[1][8][9] = 8.78310724587;
   fDecTF_1[1][9][0] = 1.89385080974;
   fDecTF_1[1][9][1] = 0.0176413334656;
   fDecTF_1[1][9][2] = 0.72704256824;
   fDecTF_1[1][9][3] = -9.83253368792;
   fDecTF_1[1][9][4] = -1.02202113775;
   fDecTF_1[1][9][5] = 1.04454621784;
   fDecTF_1[1][9][6] = 0.0684181769473;
   fDecTF_1[1][9][7] = 0.0575872089294;
   fDecTF_1[1][9][8] = 8.78310724587;
   fDecTF_1[1][9][9] = 43.4090245268;
   fDecTF_1[2][0][0] = 5.32556800049;
   fDecTF_1[2][0][1] = -0.159991559008;
   fDecTF_1[2][0][2] = -1.04071997889;
   fDecTF_1[2][0][3] = -2.67668330972;
   fDecTF_1[2][0][4] = -0.36694160128;
   fDecTF_1[2][0][5] = 0.196546724778;
   fDecTF_1[2][0][6] = 0.648152391252;
   fDecTF_1[2][0][7] = -0.102306412388;
   fDecTF_1[2][0][8] = 1.09628188473;
   fDecTF_1[2][0][9] = 1.55646309374;
   fDecTF_1[2][1][0] = -0.159991559008;
   fDecTF_1[2][1][1] = 0.79719508313;
   fDecTF_1[2][1][2] = -0.0814964377802;
   fDecTF_1[2][1][3] = -0.191837331463;
   fDecTF_1[2][1][4] = -0.0535267480178;
   fDecTF_1[2][1][5] = -0.0885663589102;
   fDecTF_1[2][1][6] = 0.0372496259464;
   fDecTF_1[2][1][7] = -0.0220804078216;
   fDecTF_1[2][1][8] = -0.028257327324;
   fDecTF_1[2][1][9] = -0.0065140315635;
   fDecTF_1[2][2][0] = -1.04071997889;
   fDecTF_1[2][2][1] = -0.0814964377802;
   fDecTF_1[2][2][2] = 13.5106002514;
   fDecTF_1[2][2][3] = -1.91595876496;
   fDecTF_1[2][2][4] = -3.14798800301;
   fDecTF_1[2][2][5] = -4.95478904358;
   fDecTF_1[2][2][6] = 0.295872916581;
   fDecTF_1[2][2][7] = -0.135379974081;
   fDecTF_1[2][2][8] = -0.751450237633;
   fDecTF_1[2][2][9] = 0.840069638226;
   fDecTF_1[2][3][0] = -2.67668330972;
   fDecTF_1[2][3][1] = -0.191837331463;
   fDecTF_1[2][3][2] = -1.91595876496;
   fDecTF_1[2][3][3] = 14.5862898019;
   fDecTF_1[2][3][4] = 0.843953122138;
   fDecTF_1[2][3][5] = -1.66155386681;
   fDecTF_1[2][3][6] = 0.613240560473;
   fDecTF_1[2][3][7] = -0.206630385139;
   fDecTF_1[2][3][8] = -6.01705994487;
   fDecTF_1[2][3][9] = -6.87225428904;
   fDecTF_1[2][4][0] = -0.36694160128;
   fDecTF_1[2][4][1] = -0.0535267480178;
   fDecTF_1[2][4][2] = -3.14798800301;
   fDecTF_1[2][4][3] = 0.843953122138;
   fDecTF_1[2][4][4] = 7.21252102091;
   fDecTF_1[2][4][5] = -0.608310401933;
   fDecTF_1[2][4][6] = -0.112891533776;
   fDecTF_1[2][4][7] = -0.00290727671501;
   fDecTF_1[2][4][8] = 0.232797500526;
   fDecTF_1[2][4][9] = -0.643383551477;
   fDecTF_1[2][5][0] = 0.196546724778;
   fDecTF_1[2][5][1] = -0.0885663589102;
   fDecTF_1[2][5][2] = -4.95478904358;
   fDecTF_1[2][5][3] = -1.66155386681;
   fDecTF_1[2][5][4] = -0.608310401933;
   fDecTF_1[2][5][5] = 14.4145582382;
   fDecTF_1[2][5][6] = -0.319137651677;
   fDecTF_1[2][5][7] = -0.0161326135241;
   fDecTF_1[2][5][8] = 0.0558457612828;
   fDecTF_1[2][5][9] = 0.752411684462;
   fDecTF_1[2][6][0] = 0.648152391252;
   fDecTF_1[2][6][1] = 0.0372496259464;
   fDecTF_1[2][6][2] = 0.295872916581;
   fDecTF_1[2][6][3] = 0.613240560473;
   fDecTF_1[2][6][4] = -0.112891533776;
   fDecTF_1[2][6][5] = -0.319137651677;
   fDecTF_1[2][6][6] = 1.97373126708;
   fDecTF_1[2][6][7] = -0.0366721822714;
   fDecTF_1[2][6][8] = 0.105364970853;
   fDecTF_1[2][6][9] = -0.108679150368;
   fDecTF_1[2][7][0] = -0.102306412388;
   fDecTF_1[2][7][1] = -0.0220804078216;
   fDecTF_1[2][7][2] = -0.135379974081;
   fDecTF_1[2][7][3] = -0.206630385139;
   fDecTF_1[2][7][4] = -0.00290727671501;
   fDecTF_1[2][7][5] = -0.0161326135241;
   fDecTF_1[2][7][6] = -0.0366721822714;
   fDecTF_1[2][7][7] = 4.07861535012;
   fDecTF_1[2][7][8] = 0.0905948569856;
   fDecTF_1[2][7][9] = 0.130541632568;
   fDecTF_1[2][8][0] = 1.09628188473;
   fDecTF_1[2][8][1] = -0.028257327324;
   fDecTF_1[2][8][2] = -0.751450237633;
   fDecTF_1[2][8][3] = -6.01705994487;
   fDecTF_1[2][8][4] = 0.232797500526;
   fDecTF_1[2][8][5] = 0.0558457612828;
   fDecTF_1[2][8][6] = 0.105364970853;
   fDecTF_1[2][8][7] = 0.0905948569856;
   fDecTF_1[2][8][8] = 16.9315519644;
   fDecTF_1[2][8][9] = 4.11710467195;
   fDecTF_1[2][9][0] = 1.55646309374;
   fDecTF_1[2][9][1] = -0.0065140315635;
   fDecTF_1[2][9][2] = 0.840069638226;
   fDecTF_1[2][9][3] = -6.87225428904;
   fDecTF_1[2][9][4] = -0.643383551477;
   fDecTF_1[2][9][5] = 0.752411684462;
   fDecTF_1[2][9][6] = -0.108679150368;
   fDecTF_1[2][9][7] = 0.130541632568;
   fDecTF_1[2][9][8] = 4.11710467195;
   fDecTF_1[2][9][9] = 40.3624940643;
}

//_______________________________________________________________________
inline void ReadCutsD::Transform_1( std::vector<double>& iv, int cls) const
{
   // Decorrelation transformation
   if (cls < 0 || cls > 2) {
       if (2 > 1 ) cls = 2;
       else cls = 2;
   }

   // define the indices of the variables which are transformed by this transformation
   static std::vector<int> indicesGet;
   static std::vector<int> indicesPut;

   if ( indicesGet.empty() ) { 
      indicesGet.reserve(fNvars);
      indicesGet.push_back( 0);
      indicesGet.push_back( 1);
      indicesGet.push_back( 2);
      indicesGet.push_back( 3);
      indicesGet.push_back( 4);
      indicesGet.push_back( 5);
      indicesGet.push_back( 6);
      indicesGet.push_back( 7);
      indicesGet.push_back( 8);
      indicesGet.push_back( 9);
   } 
   if ( indicesPut.empty() ) { 
      indicesPut.reserve(fNvars);
      indicesPut.push_back( 0);
      indicesPut.push_back( 1);
      indicesPut.push_back( 2);
      indicesPut.push_back( 3);
      indicesPut.push_back( 4);
      indicesPut.push_back( 5);
      indicesPut.push_back( 6);
      indicesPut.push_back( 7);
      indicesPut.push_back( 8);
      indicesPut.push_back( 9);
   } 

   std::vector<double> tv;
   for (int i=0; i<10;i++) {
      double v = 0;
      for (int j=0; j<10; j++)
         v += iv[indicesGet.at(j)] * fDecTF_1[cls][i][j];
      tv.push_back(v);
   }
   for (int i=0; i<10;i++) iv[indicesPut.at(i)] = tv[i];
}

//_______________________________________________________________________
inline void ReadCutsD::InitTransform()
{
   InitTransform_1();
}

//_______________________________________________________________________
inline void ReadCutsD::Transform( std::vector<double>& iv, int sigOrBgd ) const
{
   Transform_1( iv, sigOrBgd );
}
